package ca.mcgill.ecse211.lab4;

import static ca.mcgill.ecse211.lab4.Resources.*;
import lejos.hardware.Sound;
import lejos.hardware.ev3.LocalEV3;
import lejos.hardware.port.Port;
import lejos.hardware.sensor.EV3ColorSensor;
import lejos.hardware.sensor.SensorModes;
import lejos.robotics.SampleProvider;

public class LightLocalizer {

  private static final Port colourSampler = LocalEV3.get().getPort("S2");
  private SensorModes colourSamplerSensor = new EV3ColorSensor(colourSampler);
  private SampleProvider colourSensorValue = colourSamplerSensor.getMode("Red");
  private float[] colourSensorValues = new float[colourSamplerSensor.sampleSize()];
  
  private float colorValue;
  
  double[] lineMeasures;
  
  /**
   * This method localizes the robot using the light sensor
   * 
   */

  public void localize() {
    
    double dx, dy, thetaX, thetaY;
    
    int index = 0;
    
    leftMotor.setSpeed(ROTATE_SPEED);
    rightMotor.setSpeed(ROTATE_SPEED);
    
    goToOrigin();
    
    while (index < 4) {
      
      leftMotor.forward();
      rightMotor.backward();
      
      colorValue = readColorData();
      
      if (colorValue < 0.38) {
        lineMeasures[index] = odometer.getXYT()[2];
        Sound.beep();
        index++;
      }
    }
    
    leftMotor.stop(true);
    rightMotor.stop();
    
    thetaX = lineMeasures[2] - lineMeasures[0];
    thetaY = lineMeasures[3] - lineMeasures[1];
    
    dx = -1 * COLOR_SENSOR_LENGTH * Math.cos(Math.toRadians(thetaY / 2));
    dy = -1 * COLOR_SENSOR_LENGTH * Math.cos(Math.toRadians(thetaX / 2));
    
    odometer.setXYT(dx, dy, odometer.getXYT()[2]);
    travelTo(0.0, 0.0);
    
    leftMotor.setSpeed(ROTATE_SPEED/2);
    rightMotor.setSpeed(ROTATE_SPEED/2);
    
    if (odometer.getXYT()[2] > 10.0 && odometer.getXYT()[2] <= 350.0) {
      Sound.beep();
      leftMotor.rotate(radToDeg(-odometer.getXYT()[2]), true);
      rightMotor.rotate(-radToDeg(-odometer.getXYT()[2]), false);
    }
    
    leftMotor.stop(true);
    rightMotor.stop();
    
  }
  
  /**
   * This method makes the robot go to the origin
   * 
   */
  
  public void goToOrigin() {
    
    turnTo(Math.PI / 4);
    
    leftMotor.setSpeed(ROTATE_SPEED);
    rightMotor.setSpeed(ROTATE_SPEED);
    
    colorValue = readColorData();
    
    while (colorValue > 0.38) {
      colorValue = readColorData();
      leftMotor.forward();
      rightMotor.forward();
    }
    
    leftMotor.stop(true);
    rightMotor.stop();
    Sound.beep();
    
    leftMotor.rotate(distanceToRotations(-12), true);
    rightMotor.rotate(distanceToRotations(-12), false);
    
  }
  
  /**
   * This method calculates the vehicle displacement through x/y
   * and the turning angle (theta). It then sets the rotations 
   * needed to reach the x/y point.
   * 
   * @param x
   * @param y
   */
  
  public void travelTo(double x, double y) {

    double dx, dy, displacement, theta;

    double currentX = odometer.getXYT()[0];
    double currentY = odometer.getXYT()[1];
    
    dx = x - currentX;
    dy = y - currentY;
    
    displacement = Math.hypot(dx, dy);
    theta = Math.atan2(dx, dy);

    turnTo(theta);

    leftMotor.setSpeed(FORWARD_SPEED);
    rightMotor.setSpeed(FORWARD_SPEED);

    leftMotor.rotate(distanceToRotations(displacement), true);
    rightMotor.rotate(distanceToRotations(displacement), false);

    leftMotor.stop(true);
    rightMotor.stop(true);
  }
  
  /**
   * This method makes the robot turn to theta
   * 
   * @param theta
   */
  
  public void turnTo(double theta) {
    
    theta = getMinAngle(theta);
    
    leftMotor.setSpeed(ROTATE_SPEED);
    rightMotor.setSpeed(ROTATE_SPEED);
    
    if (theta < 0) {
      leftMotor.rotate(-radToDeg(-theta), true);
      rightMotor.rotate(radToDeg(-theta), false);
    }
    else {
      leftMotor.rotate(radToDeg(theta), true);
      rightMotor.rotate(-radToDeg(theta), false);
    }
  }
  
  /**
   * This method returns the current value of the color sensor
   * 
   * @return
   */
  
  private float readColorData() {
    colourSensorValue.fetchSample(colourSensorValues, 0);
    return colourSensorValues[0];
  }

  private int distanceToRotations(double distance) {
    return (int) (180.0 * distance / (Math.PI * WHEEL_RAD));
  }

  private int radToDeg(double angle) {
    return distanceToRotations(TRACK * angle / 2);
  }
  
  /**
   * This method calculates the minimum value of an angle
   * 
   * @param angle
   * @return
   */
  
  public double getMinAngle(double angle) {
    if (angle > Math.PI) {
      angle -= 2 * Math.PI;
    } else if (angle < -Math.PI) {
      angle += 2 * Math.PI ;
    }
    return angle;
  }

}
