package ca.mcgill.ecse211.lab3;

import static ca.mcgill.ecse211.lab3.Resources.*;

/**
 * This class implements methods for the navigation of the robot through waypoints
 * @author Tony
 *
 */

public class Navigation implements Runnable {

  // The robot is not moving initially

  private static boolean navigating = false;

  private Odometer odometer;
  
  private double thetaNow, xNow, yNow;  // current heading
  
  /**
   * The odometer update period in ms.
   */
  private static final long ODOMETER_PERIOD = 25;

  public Navigation (Odometer odometer){
    this.odometer = odometer;
    leftMotor.setAcceleration(ACCELERATION);
    rightMotor.setAcceleration(ACCELERATION);
    navigating = false;
  }

  public void run() {
    long updateStart, updateEnd;
    while (true) {
      updateStart = System.currentTimeMillis();

      getCoordinates();

      // this ensures that the odometer only runs once every period
      updateEnd = System.currentTimeMillis();
      if (updateEnd - updateStart < ODOMETER_PERIOD) {
        try {
          Thread.sleep(ODOMETER_PERIOD - (updateEnd - updateStart));
        } catch (InterruptedException e) {
          // there is nothing to be done here because it is not
          // expected that the odometer will be interrupted by
          // another thread
        }
      }
    }
  }

  /**
   * This method calculates the vehicle displacement through x/y
   * and the turning angle (theta). It then sets the rotations 
   * needed to reach the right waypoint.
   * 
   * @param x
   * @param y
   */

  public void travelTo(double x, double y) {

    // Initialize variables

    double dx, dy, displacement, theta;

    // Get current position

    double currentX = odometer.getXYT()[0];
    double currentY = odometer.getXYT()[1];
    double currentTheta = odometer.getXYT()[2];

    // Robot is navigating

    navigating = true;

    // Get the displacement and the angle to reach the
    // waypoint at (x, y)

    dx = x - currentX;
    dy = y - currentY;
    displacement = Math.hypot(dx, dy);
    theta = Math.atan2(dx, dy) - currentTheta;

    turnTo(theta);

    // Cover the distance to the waypoint

    leftMotor.setAcceleration(ACCELERATION);
    rightMotor.setAcceleration(ACCELERATION);
    leftMotor.setSpeed(FORWARD_SPEED);
    rightMotor.setSpeed(FORWARD_SPEED);

    navigating = true;
    leftMotor.forward();
    rightMotor.forward();

    // Return one value immediately so only 3 threads are running

    leftMotor.rotate(distanceToRotations(displacement), true);
    rightMotor.rotate(distanceToRotations(displacement), false);

    leftMotor.stop();
    rightMotor.stop();

    navigating = false;
  }

  /**
   * This method takes a distance and converts it to the
   * number of wheel rotations needed
   * 
   * @param distance
   * @return
   */

  private int distanceToRotations(double distance) {
    return (int) (180.0 * distance / (Math.PI * WHEEL_RAD));
  }

  /**
   * This method makes the robot turn to the right waypoint
   * 
   * @param theta
   */

  public void turnTo(double theta) {

    leftMotor.setSpeed(ROTATE_SPEED);
    rightMotor.setSpeed(ROTATE_SPEED);

    // Get the minimal angle first

    double turnAngle = Math.toDegrees(theta);

    // Return one value immediately so only 3 threads are running

    navigating = true;

    leftMotor.rotate(radToDeg(turnAngle), true);
    rightMotor.rotate(-radToDeg(turnAngle), false);
    navigating = false;

    leftMotor.stop();
    rightMotor.stop();

  }

  /**
   * This method takes an angle and uses a formula
   * to convert it to its minimum value
   * 
   * @param angle
   * @return
   */

  public double getMinAngle(double angle) {
    if (angle > Math.PI) {
      angle -= 2 * Math.PI;
    } else if (angle < -Math.PI) {
      angle += 2 * Math.PI ;
    }
    return angle;
  }

  /**
   * This method transforms the angle in rad to degrees
   * 
   * @param angle
   * @return
   */

  private int radToDeg(double angle) {
    return distanceToRotations(TRACK * angle / 2);
  }

  /**
   * This method returns if the robot is travelling or not
   * 
   * @return
   */

  public boolean isNavigating() {
    return navigating;
  }
  
  public void getCoordinates() {
    // synchronize robot's current position
    synchronized (odometer.lock) {
        thetaNow = odometer.getTheta();
        xNow = odometer.getX();
        yNow = odometer.getY();
    }
}

}
